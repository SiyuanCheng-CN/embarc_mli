/*
* Copyright 2019-2020, Synopsys, Inc.
* All rights reserved.
*
* This source code is licensed under the BSD-3-Clause license found in
* the LICENSE file in the root directory of this source tree.
*
*/

#include "mli_config.h"
#include "mli_prv_lut.h"
#include "mli_prv_activation_lut.h"

using mli::krn::activation_lut;

/*
    *** Generated by lutfx.py ***
    arguments  = -t FX16 -o size/2 -s 180 -qi 3 -f 'sigm(x)'
    lut_size   = 180
    in_offset  = 90
    in_format  = Q4.3
    out_format = Q15
    out_error  = 0.000191 (6 lsb) (linear interpolation)
*/
static const MLI_CCM_ATT int16_t sigmoid_lut_data_fx16[] = {
        +0,     +0,     +1,     +1,     +1,     +1,     +1,     +1,     +1,     +1,     +1,     +2,     +2,     +2,
        +2,     +3,     +3,     +4,     +4,     +5,     +5,     +6,     +7,     +8,     +9,     +10,    +11,    +12,
        +14,    +16,    +18,    +21,    +23,    +26,    +30,    +34,    +38,    +43,    +49,    +56,    +63,    +72,
        +81,    +92,    +104,   +118,   +133,   +151,   +171,   +194,   +219,   +248,   +281,   +318,   +360,   +407,
        +461,   +521,   +589,   +666,   +753,   +851,   +961,   +1084,  +1223,  +1379,  +1554,  +1750,  +1969,  +2213,
        +2486,  +2789,  +3124,  +3496,  +3906,  +4357,  +4851,  +5391,  +5978,  +6613,  +7297,  +8031,  +8813,  +9641,
        +10513, +11424, +12371, +13348, +14347, +15361, +16384, +17407, +18421, +19420, +20397, +21344, +22255, +23127,
        +23955, +24737, +25471, +26155, +26790, +27377, +27917, +28411, +28862, +29272, +29644, +29979, +30282, +30555,
        +30799, +31018, +31214, +31389, +31545, +31684, +31807, +31917, +32015, +32102, +32179, +32247, +32307, +32361,
        +32408, +32450, +32487, +32520, +32549, +32574, +32597, +32617, +32635, +32650, +32664, +32676, +32687, +32696,
        +32705, +32712, +32719, +32725, +32730, +32734, +32738, +32742, +32745, +32747, +32750, +32752, +32754, +32756,
        +32757, +32758, +32759, +32760, +32761, +32762, +32763, +32763, +32764, +32764, +32765, +32765, +32766, +32766,
        +32766, +32766, +32767, +32767, +32767, +32767, +32767, +32767, +32767, +32767, +32767, +32767};

const mli_lut sigmoid_lut_fx16 = {
        // Designated initializers in C++ is a C++20 feature
        /*.data =*/ (const void*)sigmoid_lut_data_fx16,
        /*.type =*/ MLI_EL_FX_16,
        /*.length =*/ sizeof(sigmoid_lut_data_fx16) / sizeof(sigmoid_lut_data_fx16[0]),
        /*.frac_bits =*/ 3,
        /*.offset =*/ sizeof(sigmoid_lut_data_fx16) / (sizeof(sigmoid_lut_data_fx16[0]) * 2) /*center-aligned */
};

/*
    *** Generated by lutfx.py ***
    arguments  = -t FX16 -o size/2 -s 178 -qi 4 -f 'tanh(x)'
    lut_size   = 178
    in_offset  = 89
    in_format  = Q3.4
    out_format = Q15
    out_error  = 0.000377 (12 lsb) (linear interpolation)
*/
static const MLI_CCM_ATT int16_t tanh_lut_data_fx16[] = {
        -32767, -32767, -32767, -32767, -32766, -32766, -32766, -32766, -32765, -32765, -32765, -32764, -32764, -32763,
        -32762, -32762, -32761, -32760, -32759, -32758, -32756, -32755, -32753, -32751, -32749, -32746, -32743, -32740,
        -32736, -32732, -32727, -32721, -32715, -32708, -32700, -32691, -32681, -32670, -32657, -32642, -32625, -32606,
        -32584, -32560, -32532, -32501, -32466, -32426, -32381, -32329, -32271, -32206, -32132, -32048, -31953, -31846,
        -31726, -31589, -31435, -31262, -31067, -30847, -30600, -30322, -30010, -29660, -29268, -28830, -28341, -27797,
        -27191, -26519, -25776, -24956, -24054, -23066, -21986, -20813, -19542, -18173, -16706, -15143, -13486, -11743,
        -9919,  -8025,  -6073,  -4075,  -2045,  +0,     +2045,  +4075,  +6073,  +8025,  +9919,  +11743, +13486, +15143,
        +16706, +18173, +19542, +20813, +21986, +23066, +24054, +24956, +25776, +26519, +27191, +27797, +28341, +28830,
        +29268, +29660, +30010, +30322, +30600, +30847, +31067, +31262, +31435, +31589, +31726, +31846, +31953, +32048,
        +32132, +32206, +32271, +32329, +32381, +32426, +32466, +32501, +32532, +32560, +32584, +32606, +32625, +32642,
        +32657, +32670, +32681, +32691, +32700, +32708, +32715, +32721, +32727, +32732, +32736, +32740, +32743, +32746,
        +32749, +32751, +32753, +32755, +32756, +32758, +32759, +32760, +32761, +32762, +32762, +32763, +32764, +32764,
        +32765, +32765, +32765, +32766, +32766, +32766, +32766, +32767, +32767, +32767};

const mli_lut tanh_lut_fx16 = {
        /*.data =*/ (const void*)tanh_lut_data_fx16,
        /*.type =*/ MLI_EL_FX_16,
        /*.length =*/ sizeof(tanh_lut_data_fx16) / sizeof(tanh_lut_data_fx16[0]),
        /*.frac_bits =*/ 4,
        /*.offset =*/ sizeof(tanh_lut_data_fx16) / (sizeof(tanh_lut_data_fx16[0]) * 2) /*center-aligned */
};

/*
    *** Generated by lutfx.py ***
    arguments  = -t FX16 -o size-2 -s 181 -qi 4 -f 'expneg(x)'
    lut_size   = 181
    in_offset  = 179
    in_format  = Q3.4
    out_format = Q15
    out_error  = 0.000463 (15 lsb) (linear interpolation)
*/
static const MLI_CCM_ATT int16_t expneg_lut_data_fx16[] = {
        +0,     +0,     +1,     +1,     +1,     +1,     +1,     +1,     +1,     +1,     +1,     +1,     +1,     +1,
        +1,     +1,     +1,     +1,     +1,     +1,     +2,     +2,     +2,     +2,     +2,     +2,     +2,     +2,
        +3,     +3,     +3,     +3,     +3,     +4,     +4,     +4,     +4,     +5,     +5,     +5,     +6,     +6,
        +6,     +7,     +7,     +8,     +8,     +9,     +9,     +10,    +10,    +11,    +12,    +12,    +13,    +14,
        +15,    +16,    +17,    +18,    +19,    +21,    +22,    +23,    +25,    +26,    +28,    +30,    +32,    +34,
        +36,    +38,    +41,    +43,    +46,    +49,    +52,    +56,    +59,    +63,    +67,    +72,    +76,    +81,
        +86,    +92,    +98,    +104,   +111,   +118,   +126,   +134,   +143,   +152,   +162,   +172,   +183,   +195,
        +207,   +221,   +235,   +250,   +266,   +283,   +302,   +321,   +342,   +364,   +387,   +412,   +439,   +467,
        +498,   +530,   +564,   +600,   +639,   +680,   +724,   +771,   +820,   +873,   +930,   +990,   +1053,  +1121,
        +1194,  +1271,  +1352,  +1440,  +1533,  +1631,  +1737,  +1849,  +1968,  +2095,  +2230,  +2374,  +2527,  +2690,
        +2863,  +3048,  +3244,  +3454,  +3676,  +3914,  +4166,  +4435,  +4721,  +5025,  +5349,  +5694,  +6061,  +6452,
        +6869,  +7312,  +7783,  +8285,  +8819,  +9388,  +9994,  +10638, +11324, +12055, +12832, +13660, +14541, +15479,
        +16477, +17539, +18671, +19875, +21157, +22521, +23974, +25520, +27166, +28918, +30783, +32767, +32767};

const mli_lut expneg_lut_fx16 = {
        /*.data =*/ (const void*)expneg_lut_data_fx16,
        /*.type =*/ MLI_EL_FX_16,
        /*.length =*/ sizeof(expneg_lut_data_fx16) / sizeof(expneg_lut_data_fx16[0]),
        /*.frac_bits =*/ 4,
        /*.offset =*/ sizeof(expneg_lut_data_fx16) / sizeof(expneg_lut_data_fx16[0]) - 2 /*right-minus-one-aligned */
};

/*
    *** Generated by lutfx.py ***
    arguments  = -t FX16 -o -10 -s 256 -qi 0 -f 'invsqrt(x)'
    lut_size   = 256
    in_offset  = -10
    in_format  = Q15.0
    out_format = Q15
    out_error  = 0.000262 (9 lsb) (linear interpolation)
*/
static const int16_t invsqrt_lut_data_fx16[] = {
     +10362,  +9880,  +9459,  +9088,  +8758,  +8461,  +8192,  +7947,
     +7723,  +7517,  +7327,  +7151,  +6986,  +6833,  +6689,  +6554,
     +6426,  +6306,  +6193,  +6085,  +5983,  +5885,  +5793,  +5704,
     +5620,  +5539,  +5461,  +5387,  +5316,  +5247,  +5181,  +5118,
     +5056,  +4997,  +4940,  +4885,  +4831,  +4780,  +4730,  +4681,
     +4634,  +4588,  +4544,  +4501,  +4459,  +4418,  +4379,  +4340,
     +4303,  +4266,  +4230,  +4196,  +4162,  +4128,  +4096,  +4064,
     +4033,  +4003,  +3974,  +3945,  +3917,  +3889,  +3862,  +3835,
     +3809,  +3784,  +3759,  +3734,  +3710,  +3687,  +3664,  +3641,
     +3619,  +3597,  +3575,  +3554,  +3533,  +3513,  +3493,  +3473,
     +3454,  +3435,  +3416,  +3398,  +3380,  +3362,  +3344,  +3327,
     +3310,  +3293,  +3277,  +3261,  +3245,  +3229,  +3213,  +3198,
     +3183,  +3168,  +3153,  +3139,  +3124,  +3110,  +3096,  +3083,
     +3069,  +3056,  +3042,  +3029,  +3017,  +3004,  +2991,  +2979,
     +2967,  +2955,  +2943,  +2931,  +2919,  +2908,  +2896,  +2885,
     +2874,  +2863,  +2852,  +2841,  +2831,  +2820,  +2810,  +2800,
     +2789,  +2779,  +2769,  +2760,  +2750,  +2740,  +2731,  +2721,
     +2712,  +2703,  +2694,  +2684,  +2675,  +2667,  +2658,  +2649,
     +2641,  +2632,  +2624,  +2615,  +2607,  +2599,  +2591,  +2582,
     +2574,  +2567,  +2559,  +2551,  +2543,  +2536,  +2528,  +2521,
     +2513,  +2506,  +2499,  +2491,  +2484,  +2477,  +2470,  +2463,
     +2456,  +2449,  +2442,  +2436,  +2429,  +2422,  +2416,  +2409,
     +2403,  +2396,  +2390,  +2384,  +2377,  +2371,  +2365,  +2359,
     +2353,  +2347,  +2341,  +2335,  +2329,  +2323,  +2317,  +2311,
     +2306,  +2300,  +2294,  +2289,  +2283,  +2278,  +2272,  +2267,
     +2261,  +2256,  +2251,  +2245,  +2240,  +2235,  +2230,  +2224,
     +2219,  +2214,  +2209,  +2204,  +2199,  +2194,  +2189,  +2185,
     +2180,  +2175,  +2170,  +2165,  +2161,  +2156,  +2151,  +2147,
     +2142,  +2138,  +2133,  +2129,  +2124,  +2120,  +2115,  +2111,
     +2106,  +2102,  +2098,  +2093,  +2089,  +2085,  +2081,  +2077,
     +2072,  +2068,  +2064,  +2060,  +2056,  +2052,  +2048,  +2044,
     +2040,  +2036,  +2032,  +2028,  +2024,  +2021,  +2017,  +2013
};

const mli_lut invsqrt_lut_fx16 = {
        /*.data =*/ (const void*)invsqrt_lut_data_fx16,
        /*.type =*/ MLI_EL_FX_16,
        /*.length =*/ sizeof(invsqrt_lut_data_fx16) / sizeof(invsqrt_lut_data_fx16[0]),
        /*.frac_bits =*/ 0,
        /*.offset =*/ -10
};
#ifdef __cplusplus
extern "C" {
#endif

#pragma MLI_CODE_SECTION_START(".mli_lib")

void mli_prv_activation_lut_fx8(
        const mli_tensor *in,
        const mli_tensor *out,
        const mli_lut *lut,
        int in_frac_bits) {

    auto in_prv =  mli_prv_get_generic_tensor<MLI_PTR(int8_t)>(in);
    auto out_prv =  mli_prv_get_generic_tensor<MLI_OUT_PTR(int8_t)>(out);

    /* Reordering shapes/mem_stirde to place the inner most dim at last shape */
    mli_prv_reorder_generic_tensor<MLI_PTR(int8_t)>(&in_prv );
    mli_prv_reorder_generic_tensor<MLI_OUT_PTR(int8_t)>(&out_prv);

    activation_lut<int8_t>(&in_prv, &out_prv, lut, in_frac_bits);
}

void mli_prv_activation_lut_fx16(
        const mli_tensor *in,
        const mli_tensor *out,
        const mli_lut *lut,
        int in_frac_bits) {

    auto in_prv =  mli_prv_get_generic_tensor<MLI_PTR(int16_t)>(in);
    auto out_prv =  mli_prv_get_generic_tensor<MLI_OUT_PTR(int16_t)>(out);

    /* Reordering shapes/mem_stirde to place the inner most dim at last shape */
    mli_prv_reorder_generic_tensor<MLI_PTR(int16_t)>(&in_prv );
    mli_prv_reorder_generic_tensor<MLI_OUT_PTR(int16_t)>(&out_prv);

    activation_lut<int16_t>(&in_prv, &out_prv, lut, in_frac_bits);
}

void mli_prv_activation_lut_sa8(
        const mli_tensor *in,
        const mli_tensor *out,
        const mli_lut *lut,
        struct s8asym_quant_params *in_params,
        struct s8asym_quant_params *out_params) {

    auto in_prv =  mli_prv_get_generic_tensor<MLI_PTR(int8_t)>(in);
    auto out_prv =  mli_prv_get_generic_tensor<MLI_OUT_PTR(int8_t)>(out);

    /* Reordering shapes/mem_stirde to place the inner most dim at last shape */
    mli_prv_reorder_generic_tensor<MLI_PTR(int8_t)>(&in_prv );
    mli_prv_reorder_generic_tensor<MLI_OUT_PTR(int8_t)>(&out_prv);

    activation_lut<int8_t, true>(&in_prv, &out_prv, lut, 0 /*Unused*/, in_params, out_params);
}

#pragma MLI_CODE_SECTION_END()

#ifdef __cplusplus
}
#endif
